\chapter{Analysis}

Now that we have described the game's design, in this chapter, we will explain the approach we took to implement it from a high-level perspective.
We will provide concrete details only for what will be implemented in the playable demo version, but as always, we will make many decisions based on the original vision of our game.

\section{Game Engine}

Game engines provide many important and useful systems for us, so we can focus on implementing the game logic.
For our game, we chose Unity because it offers all the features we need, and the author is already familiar with it.
There are many game engines we could have used, and the high-level decisions presented in this chapter would be still applicable.
However, in some sections we will use nomenclature that is specific to Unity, so we assume the reader is at least familiar with it.
More information is available in the official documentation~\cite{UnityDocs}.

\section{Procedural Generation}

As explained in the previous chapter, a lot of the game will be procedurally generated including the map of a run and each battle along the way.
From the player's perspective, all this and the rewards they receive will be randomized and unpredictable.
However, each run will have a single seed that deterministically decides all the \enquote{random decisions} the game makes.
Two runs with the same seed will look identical and if the player makes the same decisions and choices, the outcomes will be the same.
This allows the players to share seeds of the runs they found interesting and compare their skill without the influence of luck.
Furthermore, this is helpful for debugging, because it lets us easily reproduce any issue with the generation just by running it with the same seed.

We want to allow the player to save the game between battles.
Here, determinism is also useful, because it allows us to save just the seed of something that was generated, instead of saving it whole.
This leads to simpler and smaller save files, but we might still want to save some of these components whole when the procedural generation takes significantly longer than just reading the serialized data.

\subsection{Random Number Generators}

Randomized algorithms, like the ones we will use for procedural generation, depend on a \emph{random number generator} as their source of randomness.
A \textbf{random number generator} (or \emph{RNG}) produces a sequence of numbers that looks random and is unpredictable.
They are well explained in \citetitle{johnston2018random}~\cite{johnston2018random} by David Johnston.
Some RNGs use specialized hardware to generate truly random data using an external source of entropy, these are called \emph{true random number generators}.
However, we want a \emph{deterministic RNG}, also known as a \emph{pseudorandom number generator} (\emph{PRNG}).
These produce the random data using a completely deterministic algorithm, but unless we know the current internal state of the generator, the outputs still can't be predicted.
The initial state of a PRNG is called the \emph{seed}, and a generator will always generate the same sequence of outputs when \emph{seeded} with the same value.

Each query advances the generator's state, so the value a deterministic random number generator returns depends on the number of previous requests.
If we used one generator for generating everything, the outcomes of different systems would depend on the order they were generated in.
For example, when a player triggers some effect that uses randomness \emph{before} generating a level, the level would be different than if the player triggered the randomized effect \emph{after} the level was generated.
To remedy this, we will utilize a simple trick we call \emph{seed branching} all throughout the procedural generation.
Whenever we want more systems to be independent of each other, we create a new RNG instance for each system, and we seed them with each with a seed generated from the old RNG in advance.
For example, we will have a master RNG seeded with the seed of the run, from which we will generate the seeds for the map generator, reward systems, etc.
The map generator itself will generate the run map and then assign a new seed to each of the levels planned on the map, and so on.

We can determine what properties are required of the RNG we are going to use from our use-case.
First, obviously, the numbers generated by the generator should be random enough.
However, the RNG doesn't have to be cryptographically secure or pass strict statistical tests, since we aren't going to use them for cryptography or scientific simulations.
Since we will create many instances of the RNG, it should be lightweight and fast to initialize.
Some of them, for example the ones used by the reward system, will persist throughout the whole run, so we need an easy way to save the RNG's current state.
So, what options do we have?

Since we are using Unity, the first RNG that comes to mind is Unity class \texttt{Random}~\cite{UnityRandom}.
It is designed to be easy to use, but it is very limited~--- for example, you have access to only one instance of the class and the same instance is used for other systems within the game engine.
This is a dealbreaker for us, because we want to create more instances, and we want to have complete control over them to ensure determinism.

Another option that's on-hand is .NET \texttt{System.Random}~\cite{SystemRandom}.
According to the documentation, instantiating a random number generator is fairly expensive.
Furthermore, there are no methods to read and set the internal state of the generator.
This becomes a problem when we want to save the state of an instance to restore it later, for example when loading a save file.
We would have to serialize and deserialize the instance, which isn't a big problem, but it feels inelegant and inefficient.

Instead, we chose to go with a more straight-forward option~--- making our own RNG.
This way, we can make the generator have all the features we need.
There are many algorithms a PRNG can use.
Johnston describes in their book~\cite{johnston2018random} some most commonly used non-cryptographic PRNGs, namely:
\begin{itemize}
    \item Linear congruential generators (LCG),
    \item Multiply with carry (MWC),
    \item XORSHIFT,
    \item Permuted congruential generators (PCG).
\end{itemize}
All of these are random enough for our use-case, given we use the right parameter values, so we chose an LCG, because it seemed the most simple to implement.
In the article \citetitle{LCGTables}~\cite{LCGTables}, the author explains the statistical tests they used to measure the randomness of the LCGs and tabulates the best-performing parameter combinations.
From here we took the parameters for our LCG implementation.


\section{Path Generation}

\xxx{I should probably write the design part first so I can build on it here}
- how to make paths with the required qualities?

\subsection{Initial Paths}

- generate fixed number of paths with given lengths

- these are just plans to ensure paths of required length exist

- first pick *start points* from along the edges of the level (all paths end in the center of the level)

- choose randomly from positions with the correct parity (even / odd path length)

- spread them out by removing all positions near already chosen one

- then generate paths

- first trace it randomly, with bias away from the start and from path tiles

- simulated annealing

- there are just plans to make sure the paths exist and the terrain in a way that ensures that the paths are not blocked

\subsection{Final Paths}

- after terrain generation, the paths are traced for real

- guaranteed shortest length

- DFS, find all branches, but continue from bottom of the stack when a paths is found

\subsection{Path Visualization}

- line renderer \checkmark

- why does it look this way

\section{Terrain Generation}

- fractal noise X

- WFC \checkmark (don't forget to mention disadvantages)

\xxx{this is gonna be multiple subsections}

\xxx{illustrate with images (from the videos I made)}

- *slots* offset compared to *tiles*

- less distinct variants

- more control over transitions

- prepare *modules*

- generate grid of *slots*, mark them as *uncollapsed*

- each *slot* can become one of many *modules*

- the *modules* that can be placed in a given slot are its *domain*

- at the start each *slot* has all *modules* in its *domain*

- from the *domain*, compute all possible *boundary conditions*

- for example - there is a *module* in the *domain* with a cliff on its east boundary, so mark cliff to the east as possible

- mark all *slots* as *dirty*

- then repeat:

- propagate constraints

- for each *dirty slot*, until there are none:

- mark as *not dirty*

- find out which *modules* from its *domain* can be placed here and remove the rest from its *domain*

- decide only by neighbors' (orthogonal and diagonal) *boundary conditions*

- update *boundary conditions*

- if *boundary conditions* changed, mark all *uncollapsed* neighbors as *dirty*

- *collapse* a slot

- save the current *state* of all *slots* on a stack

- pick a *slot*

- pick one *module* from its *domain* at random

- weighted - provides control

- remove each other *module* from its *domain*

- update *boundary conditions*

- mark *uncollapsed* neighbors as *dirty*

- if a *slot* ends up with 0 *modules* in its *domain*, backtrack

- pop a prevoiusly saved *state* from the stack and revert to it

- remove the previously chosen *module* from the *domain* of the previously *collapsed slot*


- Which slot to collapse?

- fail fast approach

- prioritize slot with least options

- changed to slot with least entropy, because that's more accurate

- slots near most constraining modules were prioritized, making them more common and leading to repetitive terrain features

- better to just collapse a random slot

- in the end still weighted by entropy

- at first I tried to prefer slots with more entropy

- define overall structure first by sparsely covering the world, then fill in details

- often led to deep dead-ends with a lot of backtracking

- in the end, tiles with less entropy are preferred

- Limited backtracking depth

- usually when more backtracking is required, the search would take too long and it's faster to restart the algorithm

\section{Resources and Obstacles}

- after terrain generation, place blockers on tiles

- materials for the player to mine

- just rocks for variety - the player cant build on these

- set up as a few stages

- each stage has:

- one type of blocker (e.g. ore, small rocks, big rocks)

- *min* and *max* amounts

- *base chance* to place

- whether they can be placed on slanted tiles

- which Terrain Types they can be on (currently there is only one)

- *forces* - effect on chance based on already placed blockers

- for example: negative force with magnitude *m* from stage *s* means the chance to place a blocker on a given tile is decreased by *m/d*  for each blocker placed in stage *s*, where *d* is its distance from the considered tile

- for each stage:

- repeat until at least min blockers have been placed (in this stage)

- for each tile without a path or blocker (in random order):

- if random number between 0 and 1 < modified chance:

- place the blocker of the given type

- if there are max blockers (placed in this stage), end the stage

- scattering

- unity physics engine X

- parallel

For the blockers, I didn't want repetitive obstacle models, so they are generated proceduraly by scattering many simpler models (decorations) on each tile

- first compute weights based on various factors (images!!!)

- distance to path

- height

- distance to other blockers

- customizable thanks to modular approach

- then scatter decorations in stages, each stage again having one type of decoration and many parameters

- for each tile in random order repeat x (specified for this stage) times:

- pick a random position within it

- calcualte the weight at this position (based on settings)

- check that it is greater than some threshold (based on settings)

- calculate the minimum distance to other decorations (from weight, based on settings)

- check that the position is far enough from other decorations

- calculate the decoration size (from weight, based on settings)

- place the decoration on this position, with the given size

\section{Terrain Types}

- what information is tied to the type

- why txt (inspector was not as legible)

\section{World Builder}

- builds the world from the generated data, it needs to be done in the main thread

\section{Attacker Wave Generation}

- creates a randomized plan of waves

- two types of waves

- combine different attackers in sequence

- combine different attackers in parallel (only possible with multiple paths, rarer)

- each wave gets some throughput budget and buffer

- each attacker has a given cost

- when planning a wave, select attackers and spacing, such that the througput budget is exceeded

- for each attacker subtract the throughput overshoot from buffer

- fit such that as much of buffer gets used without going over

\section{Simulation}

- use fixed updates for game logic

- why?

- 20Hz = fixed time step 0.05s

- options to speed up or possibly pause - changing fixed update rate - not yet implemented

\section{Visuals and Interpolation}

- interpolate positions and visuals on Update

- many visuals are game-speed agnostic     - TODO: use unscaledDeltaTime

- I thought about some custom mini-framework for this, but many of the simulated variables the visuals are based on should be handled on case-by-case basis

\section{Attacker Targeting}

- Towers use it to acquire targets

- handles which Attackers are in range and which one is chosen as the current target

- can require line of sight to the enemy

- different targeting types

- rotation

- heights

- possibly ensure a trajectory

- preferred target (configurable)

\section{Range Visualization}

- IMAGES!!

- Draw the range on the terrain mesh

- Draw on which parts of paths will Attackers be targeted

- green - all sizes

- yellow - only large

- Terrain shader uses compressed texture format instead of raw texture

- Options:

- quadrant compression format, 2bytes per node

- less CPU time, because the data is already in this format

- up to 48KiB per frame

- more GPU time

- 256x256 texture, 1byte per pixel

- more CPU time

- 64KiB per frame

- fast on GPU

- only 1 channel - cannot interpolate

- mipmaps -> one additional state

- less CPU time

- 33\% more data

- more pixels per byte

- possible future optimization

- less data

- more difficult indexing and stuff both on CPU and GPU

- interpolation could work with more than one channel and without mipmaps

\section{Game Commnds}

- we want various components to modify how other components function

- examples

- also react to events as a bonus

\section{Blueprints}

- why are they implemented this way

\subsection{Attacker Stats}

- blueprints for attackers

\subsection{Dynamic Descriptions}

- explain what things do and their stats

- attackers and blueprints

- dynamically reflect the changes made by other components
