\chapter{Analysis}

Now that we have described the game's design, in this chapter, we will explain the approach we took to implement it from a high-level perspective.
We will provide concrete details only for what will be implemented in the playable demo version, but as always, we will make many decisions based on the original vision of our game.

\section{Game Engine}

Game engines provide many important and useful systems for us, so we can focus on implementing the game logic.
For our game, we chose Unity because it offers all the features we need, and the author is already familiar with it.
There are many game engines we could have used, and the high-level decisions presented in this chapter would be still applicable.
However, in some sections we will use nomenclature that is specific to Unity, so we assume the reader is at least familiar with it.
More information is available in the official documentation~\cite{UnityDocs}.

\section{Procedural Generation}

We want the battles and individual runs to be unique, and we will accomplish this using randomized procedural generation.
Each run, including everything that gets generated within it, will be determined from a single seed.
This allows the players to share seeds of the runs they found interesting and compare their skill without the influence of luck.
Furthermore, this is helpful for debugging, because it lets us easily reproduce any issue with the generation just by running it with the same seed.
We want the game to save progress between battles, and deterministic procedural generation allows us to save just the seed for all the components the player has no control over, instead of serializing them whole.
This leads to simpler and smaller save files, however, we might still want to serialize some of these components because the procedural generation algorithms take longer than just reading the serialized data.
Most importantly, we can save all the things the player will encounter in the future, without generating them first.

The value a deterministic random number generator returns is dependent on the number of our previous requests, since each changes the generator's state.
We will utilize a simple trick we call \emph{seed branching} all throughout the procedural generation.
For example, the run map will be generated from one seed, and each level on the map will get a new random number generator with a seed based on the run seed.
These random number generators are now independent, so we can generate the levels on demand in any order without affecting the other levels.
This trick allows us to avoid race conditions, so it can even be used to generate more things in parallel.

\subsection{Random Number Generator}

We need to carefully consider which random number generator, or \emph{RNG}, we are going to use.

Since we are using Unity, the first RNG that comes to mind is Unity's class \texttt{Random}~\cite{UnityRandom}.
It is designed to be easy to use, but it is very limited~--- for example, you have access to only one instance of the class and the same instance is used for other systems within the game engine.
This is a dealbreaker for us, because we want to create more instances to use seed branching, and we want to have complete control over them to ensure determinism.

Another option that's on-hand is C\#'s \texttt{System.Random}~\cite{SystemRandom}.
However, it can only be seeded using its constructor with a 32-bit integer.
This becomes a problem when we want to save the state of an instance to restore it later, for example when loading a save file.
We would have to serialize and deserialize the instance, which isn't a big problem, but it feels inelegant and inefficient.
Even though the internal state of the default implementation of \texttt{System.Random} is 256\,bits large, according to the source code~\cite{SystemRandomSource}, we would be effectively limited to only 32-bit seeds.
Although, $2^{32}$ seeds is still a lot and there are ways to set the internal state of the RNG, we chose to go with a more straight-forward option~--- making our own RNG.

This way, we can make the generator have all the features we need.
The most important property our generator should have is that it should be simple.
It doesn't have to be cryptographically secure, it just needs to generate values that are deterministic, but seem random.
That's why we chose a linear congruential generator (\emph{LCG}).

A LCG generates its next state $x_{n+1}$ using the recurrence $x_{n+1} = (ax_n + c) \mod{m}$, where $x_n$ is the current state and $a$, $c$ and $m$ are the generator's parameters.
We need to choose the parameters carefully for our RNG to have good properties.
For example, when $a = 1$ and $c = m/2$, the generator will get stuck in a loop of only two different states.
One good property of a generator is that it has a loop of length $m$, though, this still doesn't guarantee the RNG will seem random.
For example, when $a$ and $c$ are both 1, the generator will just return each number one by one in ascending order.
There are many more properties one could consider desirable, but we won't go into more detail here.
These are described in the article \emph{Tables of Linear Congruential Generators of Different Sizes and Good Lattice Structure}~\cite{LCGTables}.
\?{where should I mention the paper for the first time}

We would like $m$ to be $2^{64}$, since this allows us to store the state of the generator in one 64-bit integer, making the implementation really simple because we get the modulo operation for free.
This is because in C\# (and natively in all CPUs), when an unsigned integer of any given size exceeds the maximum value representable for its size, it gets automatically truncated to the value modulo $2^k$ where $k$ is its size in bits.
We can find for which $a$ and $c$ do LCGs with $m = 2^{64}$ exhibit good properties in the tables mentioned above.
Specifically in table 4 we can see that one of our options is $a = 3935559000370003845$ with any $c$ that is odd, which is the parameters we chose.

\section{Path Generation}

\xxx{I should probably write the design part first so I can build on it here}
- how to make paths with the required qualities?

\subsection{Initial Paths}

- generate fixed number of paths with given lengths

- these are just plans to ensure paths of required length exist

- first pick *start points* from along the edges of the level (all paths end in the center of the level)

- choose randomly from positions with the correct parity (even / odd path length)

- spread them out by removing all positions near already chosen one

- then generate paths

- first trace it randomly, with bias away from the start and from path tiles

- simulated annealing

- there are just plans to make sure the paths exist and the terrain in a way that ensures that the paths are not blocked

\subsection{Final Paths}

- after terrain generation, the paths are traced for real

- guaranteed shortest length

- DFS, find all branches, but continue from bottom of the stack when a paths is found

\subsection{Path Visualization}

- line renderer \checkmark

- why does it look this way

\section{Terrain Generation}

- fractal noise X

- WFC \checkmark (don't forget to mention disadvantages)

\xxx{this is gonna be multiple subsections}

\xxx{illustrate with images (from the videos I made)}

- *slots* offset compared to *tiles*

- less distinct variants

- more control over transitions

- prepare *modules*

- generate grid of *slots*, mark them as *uncollapsed*

- each *slot* can become one of many *modules*

- the *modules* that can be placed in a given slot are its *domain*

- at the start each *slot* has all *modules* in its *domain*

- from the *domain*, compute all possible *boundary conditions*

- for example - there is a *module* in the *domain* with a cliff on its east boundary, so mark cliff to the east as possible

- mark all *slots* as *dirty*

- then repeat:

- propagate constraints

- for each *dirty slot*, until there are none:

- mark as *not dirty*

- find out which *modules* from its *domain* can be placed here and remove the rest from its *domain*

- decide only by neighbors' (orthogonal and diagonal) *boundary conditions*

- update *boundary conditions*

- if *boundary conditions* changed, mark all *uncollapsed* neighbors as *dirty*

- *collapse* a slot

- save the current *state* of all *slots* on a stack

- pick a *slot*

- pick one *module* from its *domain* at random

- weighted - provides control

- remove each other *module* from its *domain*

- update *boundary conditions*

- mark *uncollapsed* neighbors as *dirty*

- if a *slot* ends up with 0 *modules* in its *domain*, backtrack

- pop a prevoiusly saved *state* from the stack and revert to it

- remove the previously chosen *module* from the *domain* of the previously *collapsed slot*


- Which slot to collapse?

- fail fast approach

- prioritize slot with least options

- changed to slot with least entropy, because that's more accurate

- slots near most constraining modules were prioritized, making them more common and leading to repetitive terrain features

- better to just collapse a random slot

- in the end still weighted by entropy

- at first I tried to prefer slots with more entropy

- define overall structure first by sparsely covering the world, then fill in details

- often led to deep dead-ends with a lot of backtracking

- in the end, tiles with less entropy are preferred

- Limited backtracking depth

- usually when more backtracking is required, the search would take too long and it's faster to restart the algorithm

\section{Resources and Obstacles}

- after terrain generation, place blockers on tiles

- materials for the player to mine

- just rocks for variety - the player cant build on these

- set up as a few stages

- each stage has:

- one type of blocker (e.g. ore, small rocks, big rocks)

- *min* and *max* amounts

- *base chance* to place

- whether they can be placed on slanted tiles

- which Terrain Types they can be on (currently there is only one)

- *forces* - effect on chance based on already placed blockers

- for example: negative force with magnitude *m* from stage *s* means the chance to place a blocker on a given tile is decreased by *m/d*  for each blocker placed in stage *s*, where *d* is its distance from the considered tile

- for each stage:

- repeat until at least min blockers have been placed (in this stage)

- for each tile without a path or blocker (in random order):

- if random number between 0 and 1 < modified chance:

- place the blocker of the given type

- if there are max blockers (placed in this stage), end the stage

- scattering

- unity physics engine X

- parallel

For the blockers, I didn't want repetitive obstacle models, so they are generated proceduraly by scattering many simpler models (decorations) on each tile

- first compute weights based on various factors (images!!!)

- distance to path

- height

- distance to other blockers

- customizable thanks to modular approach

- then scatter decorations in stages, each stage again having one type of decoration and many parameters

- for each tile in random order repeat x (specified for this stage) times:

- pick a random position within it

- calcualte the weight at this position (based on settings)

- check that it is greater than some threshold (based on settings)

- calculate the minimum distance to other decorations (from weight, based on settings)

- check that the position is far enough from other decorations

- calculate the decoration size (from weight, based on settings)

- place the decoration on this position, with the given size

\section{Terrain Types}

- what information is tied to the type

- why txt (inspector was not as legible)

\section{World Builder}

- builds the world from the generated data, it needs to be done in the main thread

\section{Attacker Wave Generation}

- creates a randomized plan of waves

- two types of waves

- combine different attackers in sequence

- combine different attackers in parallel (only possible with multiple paths, rarer)

- each wave gets some throughput budget and buffer

- each attacker has a given cost

- when planning a wave, select attackers and spacing, such that the througput budget is exceeded

- for each attacker subtract the throughput overshoot from buffer

- fit such that as much of buffer gets used without going over

\section{Simulation}

- use fixed updates for game logic

- why?

- 20Hz = fixed time step 0.05s

- options to speed up or possibly pause - changing fixed update rate - not yet implemented

\section{Visuals and Interpolation}

- interpolate positions and visuals on Update

- many visuals are game-speed agnostic     - TODO: use unscaledDeltaTime

- I thought about some custom mini-framework for this, but many of the simulated variables the visuals are based on should be handled on case-by-case basis

\section{Attacker Targeting}

- Towers use it to acquire targets

- handles which Attackers are in range and which one is chosen as the current target

- can require line of sight to the enemy

- different targeting types

- rotation

- heights

- possibly ensure a trajectory

- preferred target (configurable)

\section{Range Visualization}

- IMAGES!!

- Draw the range on the terrain mesh

- Draw on which parts of paths will Attackers be targeted

- green - all sizes

- yellow - only large

- Terrain shader uses compressed texture format instead of raw texture

- Options:

- quadrant compression format, 2bytes per node

- less CPU time, because the data is already in this format

- up to 48KiB per frame

- more GPU time

- 256x256 texture, 1byte per pixel

- more CPU time

- 64KiB per frame

- fast on GPU

- only 1 channel - cannot interpolate

- mipmaps -> one additional state

- less CPU time

- 33\% more data

- more pixels per byte

- possible future optimization

- less data

- more difficult indexing and stuff both on CPU and GPU

- interpolation could work with more than one channel and without mipmaps

\section{Game Commnds}

- we want various components to modify how other components function

- examples

- also react to events as a bonus

\section{Blueprints}

- why are they implemented this way

\subsection{Attacker Stats}

- blueprints for attackers

\subsection{Dynamic Descriptions}

- explain what things do and their stats

- attackers and blueprints

- dynamically reflect the changes made by other components
