\chapter{Developer Documentation}

In this chapter we aim to describe the implementation of the demo version of our game.
In the first section~\ref{sec:docs-proj} we describe the overall structure, and in the later sections we go into more detail about the individual parts.

\section{Project Structure}\label{sec:docs-proj}

In Unity, each project is composed of individual scenes.
The scenes contain game objects to which are attached scripts that provide their behavior.
These are all saved in the project's asset folder, along with all other resources like prefabs, models, materials, textures, sounds and more.
They are separated to folders based on their type, for example all scenes are in the \emph{Scenes} folder.

In addition to the project assets, an important part of the project are the project settings.
However, these are all mostly set to their default value from the standard \emph{3D (Built-in render pipeline)} project template.
The settings that were changed are all uninteresting adjustments that an experienced Unity user would expect us to configure how we did, based on the explanation of our project provided in this chapter and chapter~\ref{analysis}.
These include for example settings in categories \emph{Tags and Layers}, \emph{Physics} and \emph{Player}.

\subsection{Scenes}

The demo version of our game is composed of 5 scenes.
We provide a brief summary of each, but we will describe them in more detail later.
This summary will be useful for the rest of the chapter, allowing us to see which parts of the game occur chronologically after other parts.
\begin{itemize}
    \item \textbf{Loading} is the first scene that gets loaded when the game starts.
          This scene contains only scripts that load data and game objects that persist throughout the entire lifetime of the application.
          After the loading is done, this scene transitions to \emph{Menu}.
    \item \textbf{Menu} contains the game title, and a button to start a run, a button to set up a custom run, and a button to exit the game.
          The start button takes the player to the \emph{Battle} scene, whereas the custom run button leads to the \emph{Run Settings} scene.
    \item \textbf{Run Settings} lets the player customize the run by selecting a custom seed or by opting to select their starting blueprints.
          There is also a button that lets the player play again the in-game tutorial.
          Starting a run from here also takes the player to the \emph{Battle} scene, unless they chose to select starting blueprints in which case they go to the \emph{Blueprint Selection} scene.
    \item \textbf{Battle} is the scene where the battles happen.
          Here the player plays one level of the game as described in previous sections, until they win the level or lose.
          If they lose, their only option is to return to \emph{Menu}.
          When they win, they continue to the \emph{Blueprint Selection} scene.
    \item In \textbf{Blueprint Selection}, the player is shown their current blueprints and new blueprints to choose from.
          When they finish choosing, they continue to the next \emph{Battle}.
\end{itemize}

\subsection{Scripts}

There are some game objects which persist between scene transitions, but most of them are confined only to one scene.
Each battle happens in one scene, but it still contains multiple systems which are loosely coupled.
The structure of the project and its systems is best seen in the structure of the \emph{Scripts} folder, which is shown in figure~\ref{fig:proj}.
Here, each node represents one folder, which can contain scripts and other folders.
The structure of the rest of this chapter will mimic the structure of our scripts.

\begin{figure}[H]
    \centering
    \begin{forest}
        forked edges,
        for tree={
                grow'=east,
                anchor=base west,
                l sep+=0.5em,
                fork sep=0.5em,
                tier/.option=level,
                calign=first,
                s sep=0mm
            },
        parent anchor=east,
        [Scripts
                    [\mono{BattleSimulation}
                        [\mono{Abilities}]
                        [\mono{Attackers}]
                        [\mono{Buildings}]
                        [\mono{Control}]
                        [\mono{Projectiles}]
                        [\mono{Selection}]
                        [\mono{Targeting}]
                        [\mono{Towers}]
                        [\mono{World}
                            [\mono{WorldBuilder}]
                            [\mono{WorldData}]
                        ]
                    ]
                    [\mono{BattleVisuals}
                        [\mono{Abilities}]
                        [\mono{Attackers}]
                        [\mono{Camera}]
                        [\mono{Effects}]
                        [\mono{Projectiles}]
                        [\mono{Selection}
                            [\mono{Highlightable}]
                        ]
                        [\mono{Towers}]
                        [\mono{UI}]
                        [\mono{World}]
                    ]
                    [\mono{Data}
                        [\mono{Loader}]
                        [\mono{Parsers}]
                        [\mono{WorldGen}]
                    ]
                    [\mono{Game}
                        [\mono{AttackerStats}]
                        [\mono{Blueprint}]
                        [\mono{InfoPanel}]
                        [\mono{Run}
                            [\mono{Events}]
                        ]
                        [\mono{Shared}]
                        [\mono{Tutorial}]
                    ]
                    [\mono{Utils}
                        [\mono{DotNetHacks}]
                        [\mono{Random}]
                    ]
                    [\mono{WorldGen}
                        [\mono{Decorations}]
                        [\mono{Obstacles}]
                        [\mono{Path}]
                        [\mono{WFC}]
                        [\mono{WorldSettings}]
                    ]
            ]
    \end{forest}
    \caption{Namespace and folder structure of our scripts.}
    \label{fig:proj}
\end{figure}

We also name the namespaces in our project according to the folder structure.
Furthermore, the project is split into assemblies, where each folder is basically one assembly.
However, assembly references can't form cycles, so all scripts in the folder \mono{WorldGen}, except for the subfolder \mono{WorldSettings} are one assembly.
Furthermore, there are a few assemblies that contain only one interface, which facilitates dependency inversion in places where we would need to create a cycle in assembly references.
These are \mono{BattleVisuals.Selection.Highlightable} and \mono{Data.Loader}.

Here, we provide a short overview of the top level script folders and the implementation of the systems they contain:
\begin{itemize}
    \item \nameref{sec:docs-sim}~--- game logic of all systems that are contained in a battle.
    \item \nameref{sec:docs-vis}~--- logic for the visuals during a battle like animations, particle effects and the user interface.
    \item \nameref{sec:docs-data}~--- parsing and loading data in the \emph{Loading} scene.
    \item \nameref{sec:docs-game}~--- systems and concepts that are present outside battle, across multiple battles or throughout the whole application runtime.
    \item \nameref{sec:docs-utils}~--- various utility functions and data structures used throughout the project.
    \item \nameref{sec:docs-worldgen}~--- procedural generation of the world for each level.
\end{itemize}
The following sections of this chapter will go into more detail.

\subsection{Third-Party Assets}
In the project, we use some assets that were not created by the author of this thesis in addition to the Unity game engine.
We would like to acknowledge and disclaim these assets here:
\begin{itemize}
    \item The Unity package \textbf{UI Soft Mask} by \emph{mob-sakai}~\cite{SoftMask}.
    \item We adapted the implementation of a \textbf{Priority Queue} from the \emph{.NET Platform}~\cite{PriorityQueue}.
    \item We also adapted an \textbf{Editor Init} script by \emph{Z4urce}~\cite{EditorInit}, used to select the scene to load when we run the game in the Unity editor.
    \item And a function for calculating the number of set bits in an \mono{int}, or \textbf{Hamming Weight}, from this \emph{stack overflow} answer~\cite{PopCount}.
    \item The font used for all text in the game is \textbf{Open Sans} by the \emph{Open Sans Project contributors}~\cite{OpenSans}.
\end{itemize}

\section{Game}\label{sec:docs-game}

In this section we will describe the purpose of the scripts in the folder \emph{Scripts/Game}, and other assets that are relevant to their function.
As stated before, this folder contains the implementation of concepts that are present throughout the game, not confined to one battle.
We will describe each of these in a separate subsection.

\subsection{Attacker Stats}

The folder \emph{Scripts/Game/AttackerStats} contains only the implementation of the \mono{AttackerStats} scriptable object.
This lets us define all attacker types as individual files and edit them in the Unity editor.
They are stored in the \emph{AttackerStats} folder.
Each attacker stats scriptable object also references the corresponding attacker prefab.
The structure of each of these prefabs is described in section \xxx{TODO: Attackers}.

\subsection{Blueprints}

Similarly to attacker stats, the folder \emph{Scripts/Game/Blueprints} contains the implementation of the \mono{Blueprint} scriptable object.
All blueprints in the game are stored in the \emph{Blueprints} folder, further organized by the blueprint type.
Each blueprint also references the corresponding building or ability, whose structure will be described in section \xxx{TODO: Battle Simulation}.

Additionally, the folder contains a few interfaces used by objects that handle blueprints.
It also includes the \mono{BlueprintDisplay} script, which implements the behavior of the prefab \emph{Prefabs/Blueprint} which is used to display the blueprints in the game.
Furthermore, it contains the script \mono{Blueprinted} which is the common base class for both buildings and abilities.

\subsection{Info Panel}

The folder \emph{Scripts/Game/InfoPanel} contains the implementation of the info panel, saved as the prefab \emph{Prefabs/InfoPanel}, which is used in the \emph{Battle} scene and \emph{BlueprintSelection} scene to show info about the selected object.
The script \mono{InfoPanel} handles the behavior of the game object.
The description displayed for the selected object is provided by a corresponding derived class of the \mono{DescriptionProvider} class.
All of these use the \mono{DescriptionFormatter} class to process a string which contains tags into icons, dynamic values and colored text, as described in section~\ref{sec:analysis-description-tags}.

\subsection{Run}

In the folder \emph{Scripts/Game/Run} are various scripts related to each individual run of the game.
The purpose of the script \mono{RunStarter} is to instantiate and configure the prefab \emph{Prefabs/RunPersistence} when starting a run.
It is used both in the scene \emph{Menu} and \emph{Run Settings}.
It also uses the script \mono{SeedEncoder} which is used to translate the seed string the player entered into a numeric value, or to generate the string representation of a random seed.

The run persistence game object the persists throughout the entirety of the player's run, and contains some other scripts from this folder:
The script \mono{RunPersistence} keeps track of the variables that persist throughout a run, between levels, and the behavior tied to them.
For example the run seed, the current level and the player's hull and blueprint collection.
The script \mono{LevelDisplay} then displays the run seed and current level of the top right corner of the screen.
Whenever \mono{RunPersistence} starts a new level, it tells \mono{LevelSetter} to set it up.
Based on the current level number, \mono{LevelSetter} sets up the parameters of the world generator (section \xxx{TODO}), wave generator (\xxx{TODO}), and battle controller (\xxx{TODO}).

After the player successfully completes a level, they go to the \emph{Blueprint Selection} scene.
The blueprint selection logic is facilitated by the \mono{BlueprintSelectionController} script, which exists only in this scene.
But first, the blueprints currently on offer are randomly selected by the \mono{BlueprintRewardController}, which is also attached to the run persistence game object.

The subfolder \emph{Scripts/Game/Run/Events} contains only the script \mono{RunEvents}.
This script contains static modifiable commands and acts as an interface between the \mono{RunPersistence} script and other scripts in the game from other assemblies.

\subsection{Shared}

The folder \emph{Scripts/Game/Shared} contains various useful scripts that are used throughout the whole game.
\mono{PersistentData} saves and loads data that is supposed to persist between individual runs of the application, for example whether the player has completed the tutorial or whether the game sounds should be muted.

The \mono{SceneController} lets other scripts change scenes by fading the screen to black, and fading in once the new scree is loaded.
This script is attached to a game object in the \emph{Loading} scene, and persists between scenes, so it is available throughout the whole runtime of the game.
The game object contains also the solid black canvas that covers the screen when fading between scenes.
Even over this curtain is a text element that shows the application version, initialized by the script \mono{VersionDisplay}.

The script \mono{SoundController} is also attached to a game object that persists throughout the lifetime of the application.
It provides to other scripts a simple way to play sound effects, using a pool of instances of the prefab \emph{Prefabs/AudioSource}.
\mono{PlaySound} then facilitates this function using a method with no arguments, by specifying the parameters of the sound to be played in the script's fields.
This is useful, because Unity events cannot call methods with more than one argument.
The script \mono{ButtonSounds} automatically makes any button or UI element it is attached to make button sounds.
Finally, the script \mono{MuteButton} controls the behavior of the mute button in the top right corner of the screen.

\subsection{Tutorial}

As one might expect, the folder \emph{Scripts/Game/Tutorial} contains the scripts which implement the in-game tutorial.
Both of the scripts are a part of the \emph{Battle} scene.
\mono{TutorialController} controls the logic of the tutorial being split into steps, and it has a Unity event for each step, so that we can assign what happens in each step in the Unity editor.
The script \mono{TutorialActions} then contains many actions that are used in the tutorial, which manipulate various values and call methods of other scripts in the scene.
It also contains come checks that advance the \mono{TutorialController} to the next step once their condition is satisfied.

\section{World Generation}\label{sec:docs-worldgen}

\section{Battle Simulation}\label{sec:docs-sim}

\section{Battle Visuals}\label{sec:docs-vis}

\section{Data}\label{sec:docs-data}

\section{Utils}\label{sec:docs-utils}

\section{Other Assets (maybe unnecessary)}
